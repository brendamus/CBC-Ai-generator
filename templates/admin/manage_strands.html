{% extends "admin/base_admin.html" %}
{% block title %}Manage Strands{% endblock %}

{% block content %}
{# Pass subjects and grades from Flask route #}
<div x-data="strandManager({{ subjects | tojson }}, {{ grades | tojson }})" x-init="fetchStrands()">

    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Manage Strands</h2>
    <div x-show="message" ... ></div> {# Same structure #}

    <div x-show="showForm" x-transition x-cloak class="bg-white p-6 rounded-lg shadow mb-6">
        <h3 class="text-xl font-semibold mb-4" x-text="formTitle()"></h3>
        <form @submit.prevent="saveStrand">
            <input type="hidden" x-model="formData.id">
            {# --- Select Subject --- #}
            <div class="mb-4">
                 <label for="strandSubject" class="block text-sm font-medium text-gray-700 mb-1">Subject</label>
                 <select id="strandSubject" x-model="formData.subject_id" required class="w-full p-2 border ...">
                      <option value="">-- Select Subject --</option>
                      <template x-for="subject in subjects" :key="subject.id">
                           <option :value="subject.id" x-text="subject.name"></option>
                      </template>
                 </select>
            </div>
             {# --- Select Grade --- #}
            <div class="mb-4">
                 <label for="strandGrade" class="block text-sm font-medium text-gray-700 mb-1">Grade</label>
                 <select id="strandGrade" x-model="formData.grade_id" required class="w-full p-2 border ...">
                      <option value="">-- Select Grade --</option>
                      <template x-for="grade in grades" :key="grade.id">
                           <option :value="grade.id" x-text="grade.name"></option>
                      </template>
                 </select>
            </div>
             {# --- Strand Name --- #}
            <div class="mb-4">
                <label for="strandName" class="block text-sm font-medium text-gray-700 mb-1">Strand Name</label>
                <input type="text" id="strandName" x-model="formData.name" required class="w-full p-2 border ...">
            </div>
            {# --- Buttons --- #}
            <div class="flex justify-end space-x-3">
                 <button type="button" @click="cancelForm()" class="bg-gray-200 ...">Cancel</button>
                 <button type="submit" class="bg-indigo-600 ..." :disabled="loading">
                    <span x-show="!loading" x-text="formSubmitButtonText()"></span><span x-show="loading">Saving...</span>
                 </button>
            </div>
        </form>
    </div>

    <div class="mb-4"><button @click="showAddForm()" class="bg-green-600 ...">+ Add New Strand</button></div>

    <div class="bg-white p-4 rounded-lg shadow overflow-x-auto">
         <div x-show="loading && items.length === 0" class="text-center py-4">Loading strands...</div>
         <table class="min-w-full ..." x-show="items.length > 0">
            <thead class="bg-gray-50">
                 <tr>
                      <th ...>ID</th><th ...>Name</th>
                      <th ...>Subject ID</th><th ...>Grade ID</th>{# Consider showing names later #}
                      <th ...>Actions</th>
                 </tr>
            </thead>
            <tbody class="bg-white divide-y ...">
                <template x-for="item in items" :key="item.id">
                    <tr>
                         <td ... x-text="item.id"></td><td ... x-text="item.name"></td>
                         <td ... x-text="item.subject_id"></td><td ... x-text="item.grade_id"></td>
                         <td class="px-6 py-4 text-right space-x-2">
                              <button @click="showEditForm(item)" class="text-indigo-600 ...">Edit</button>
                              <button @click="confirmDelete(item)" class="text-red-600 ...">Delete</button>
                         </td>
                    </tr>
                </template>
            </tbody>
        </table>
        <div x-show="!loading && items.length === 0 && !message" class="text-center py-4 text-gray-500">No strands found.</div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// --- AlpineJS Data for Strands ---
function strandManager(subjectsData, gradesData) { // Receive subjects/grades from Flask
    return {
        subjects: subjectsData || [], // Store subjects passed from Flask
        grades: gradesData || [], // Store grades passed from Flask
        items: [], showForm: false, isEditing: false, loading: false, message: '', messageType: 'success',
        formData: { id: null, name: '', subject_id: '', grade_id: '' }, // Add FK fields
        formTitle() { return this.isEditing ? 'Edit Strand' : 'Add New Strand'; },
        formSubmitButtonText() { return this.isEditing ? 'Update Strand' : 'Save Strand'; },
        showMessage(msg, type = 'success', duration = 3000) { /* ... same ... */ }, // Implement same as gradeManager
        async fetchStrands() { // Need GET /api/strands that returns ALL strands? Or filter? Let's assume GET /api/strands exists and returns all for now
            this.loading = true; this.message = ''; try { const r = await fetch('/api/strands?all=true'); /* Modify GET /api/strands if needed */ if (!r.ok) throw new Error(`Err: ${r.statusText}`); this.items = await r.json(); } catch (e) { this.showMessage(e.message||'Failed load','error'); } finally { this.loading=false;}
         },
        showAddForm() { this.isEditing = false; this.formData = { id: null, name: '', subject_id: '', grade_id: '' }; this.showForm = true; this.message = ''; },
        showEditForm(item) { this.isEditing = true; this.formData = { ...item }; this.showForm = true; this.message = ''; },
        cancelForm() { this.showForm = false; this.formData = { id: null, name: '', subject_id: '', grade_id: '' }; this.isEditing = false; },
        async saveStrand() {
            this.loading = true; this.message = '';
            const url = this.isEditing ? `/api/strands/${this.formData.id}` : '/api/strands';
            const method = this.isEditing ? 'PUT' : 'POST';
            const payload = {
                name: this.formData.name,
                subject_id: this.formData.subject_id, // Ensure these are not empty strings
                grade_id: this.formData.grade_id
            };
            if (!payload.subject_id || !payload.grade_id) { this.showMessage('Subject and Grade are required.','error'); this.loading=false; return; }

            try { const r = await fetch(url, { method: method, headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }); const d = await r.json(); if (!r.ok) throw new Error(d.error || `${method} fail`); this.showMessage(`Strand ${this.isEditing ? 'upd':'add'}!`, 'success'); this.cancelForm(); await this.fetchStrands(); } catch (e) { this.showMessage(e.message||'Fail save','error'); } finally { this.loading=false; }
        },
        confirmDelete(item) { if (confirm(`Delete Strand "${item.name}"?`)) { this.deleteStrand(item.id); } },
        async deleteStrand(id) {
            this.loading = true; this.message = ''; try { const r = await fetch(`/api/strands/${id}`, { method: 'DELETE' }); if (!r.ok) { let em='Err del'; try{const ed=await r.json();em=ed.error||em;}catch{}; throw new Error(em); } this.showMessage('Strand del!', 'success'); await this.fetchStrands(); } catch (e) { this.showMessage(e.message||'Fail del','error'); } finally { this.loading=false;}
        }
    }
}
</script>
{% endblock %}